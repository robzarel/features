[
  {
    "id": 0,
    "name": "validators",
    "description": "простые функции для валидации значений",
    "readme": [
      {
        "type": "heading",
        "content": "Общее"
      },
      {
        "type": "text",
        "content": "Каждая функция валидатор состоит из 3х частей:\n\n- Обёртка (конфигуратор), которая позволяет кастомизировать сообщения об ошибках\n- Валидатор, который непосредственно проводит валидацию\n- Результат валидации"
      },
      {
        "type": "heading",
        "content": "Сигнатуры"
      },
      {
        "type": "text",
        "content": "- Обёртка:\n \n 'type GetValidator<Options, Params> = (options: Options) => Validator<Params>;'\n \n - Валидатор:\n \n 'type Validator<T> = (params?: T) => Promise<ValidationResult>;'\n \n - Результат валидации:\n \n 'type ValidationResult = string | null;'"
      },
      {
        "type": "heading",
        "content": "Логика работы валидации"
      },
      {
        "type": "text",
        "content": "Функция 'validatevalidateValue' поочерёдно запускает валидаторы над переданным значением.\n \n Сигнатура:\n \n 'const validate: (value: any, validators: Validator[]) => Promise<ValidationResult>'\n \n Все валидаторы по умолчанию являются асинхронными и должны возвращать 'промис' с результатом валидации 'Promise<ValidationResult>'. Даже в кейсах, когда внутри валидатора не требуется асинхронная логика. Такая реализация позволяет одновременно использовать в одной подборке\n валидаторов для поля как синхронные, так и асинхронные валидаторы, при этом не усложняя кодовую базу.\n \n Рассмотрим валидацию на примере загрузки файлов с пользовательской машины. Предположим у нас есть '<input type='file' />' и пара бизнес требований:\n \n 1. ограничить максимальный вес загружаемого файла в 10мб\n 2. ограничить максимальное разрешение загружаемого изображения в 25мп (перемножение ширины на высоту должно быть не более 25 000 000 пикселей)\n \n Первое требование реализуется через синхронный валидатор. Второе - через асинхронный (например если реализовывать через img.decode() метод - https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode).\n \n И вот как раз для того, чтобы не усложнять кодовую базу валидаторов, ровно как и код, который использует эти валидаторы, мы 'приводим' все валидаторы к одному типу - делаем их все асинхронными.\n В противном случае нам пришлось бы 'ветвить' код использования синхронных и асинхронных валидаторов, плюс реализовывать пару вариантов validateValue с соответствующими типами.\n \n Поэтому система построена так, что валидаторы все по умолчанию асинхронные и при создании валидатора необходимо из него возвращать асинхронную функцию 'async', которая в свою очередь возвращает промис с результатом валидации.\n \n В случае, если вам не нужна асинхронная логика внутри валидатора - сразу же резолвим промис с нужным значением. Например:\n \n"
      },
      {
        "type": "code",
        "language": "typescript",
        "content": "import%20type%20%7B%20GetValidator%20%7D%20from%20'./index';%0A%0Aconst%20required:%20GetValidator%3Cstring,%20string%3E%20=%20(%0A%20%20message%20=%20'%D0%9E%D0%B1%D1%8F%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D0%BE%D0%BB%D0%B5'%0A)%20=%3E%20%7B%0A%20%20return%20async%20(value)%20=%3E%20(value%20?%20null%20:%20message);%0A%7D;%0A%0Aexport%20default%20required;"
      },
      {
        "type": "heading",
        "content": "Пример использования системы валидации"
      },
      {
        "type": "code",
        "language": "typescript",
        "content": "import%20type%20%7B%20Validator%20%7D%20from%20'./utils/validators';%0Aimport%20validate,%20%7B%0A%20%20required,%0A%20%20maxLength,%0A%20%20minLength,%0A%7D%20from%20'./utils/validators';%0A%0Aconst%20validators%20=%20%5Brequired(),%20minLength(5),%20maxLength(150)%5D%0Aconst%20value:%20string%20=%20'123456'%0A%0Aconst%20validationResult%20=%20validate(value,%20validators)%0A"
      },
      {
        "type": "text",
        "content": "%D0%92%20%D1%8D%D1%82%D0%BE%D0%BC%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20'validationResult'%20%D1%80%D0%B0%D0%B2%D0%BD%D0%BE%20'null',%20%D1%87%D1%82%D0%BE%20%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82%20%D1%83%D1%81%D0%BF%D0%B5%D1%88%D0%BD%D0%BE%20%D0%BF%D1%80%D0%BE%D0%B9%D0%B4%D0%B5%D0%BD%D0%BD%D1%83%D1%8E%20%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8E%20%D0%BF%D0%BE%20%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D0%BD%D0%BD%D0%BE%D0%BC%D1%83%20%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%83%20%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2.%20%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D1%8F%D0%B5%D0%BC%D0%BE%D0%B5%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20'value':%0A-%20%D0%BD%D0%B5%20%D0%BF%D1%83%D1%81%D1%82%D0%BE%D0%B5%20(%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%82%D0%BE%D1%80%20'required()')%0A-%20%D0%B8%D0%BC%D0%B5%D0%B5%D1%82%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D1%83%20%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5%205%20%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2%20(%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%82%D0%BE%D1%80%20'minLength(5)')%0A-%20%D0%B8%D0%BC%D0%B5%D0%B5%D1%82%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D1%83%20%D0%BD%D0%B5%20%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5%20150%20%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2%20(%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%82%D0%BE%D1%80%20'maxLength(150)')"
      }
    ],
    "related": []
  },
  {
    "id": 1,
    "name": "form hooks",
    "description": "react hooks для работы с формами. Могут работть в связке с валидаторами",
    "readme": [
      {
        "type": "heading",
        "content": "Общее"
      },
      {
        "type": "text",
        "content": "хуки содержат в себе модель работы с полями"
      }
    ],
    "related": []
  },
  {
    "id": 2,
    "name": "коммуникация между desktop приложениями (fdc3)",
    "description": "настройка коммуникаций между десктоп приложениями",
    "readme": [
      {
        "type": "heading",
        "content": "Общее"
      },
      {
        "type": "text",
        "content": "fdc3 это стандарт, описывающий коммуникации между десктоп приложениями"
      }
    ],
    "related": []
  },
  {
    "id": 3,
    "name": "color theming",
    "description": "Переключение цветовых тем в приложении",
    "readme": [
      {
        "type": "heading",
        "content": "Общее"
      },
      {
        "type": "text",
        "content": "идея простая - создаём контекст, отдаём его вниз. Так же создаём компоненты управления через подход compound components"
      }
    ],
    "related": []
  },
  {
    "id": 4,
    "name": "загрузка файлов",
    "description": "dnd, валидация, параллельная загрузка и отображение статусов",
    "readme": [
      {
        "type": "heading",
        "content": "Общее"
      },
      {
        "type": "text",
        "content": "Несколько компонентов. Провайдер (подход compound components), несколько элементов управления (аплоадер файлов, резолвер конфликтов). Тонкости есть с очищением инпута (так как он не позволяет грузить последовательно файлы с одинаковыми именами"
      }
    ],
    "related": []
  },
  {
    "id": 5,
    "name": "microfrontend",
    "description": "микрофронты) что тут добавишь",
    "readme": [
      {
        "type": "heading",
        "content": "Общее"
      },
      {
        "type": "text",
        "content": "Пройденный курс: https://www.udemy.com/course/microfrontend-course/"
      }
    ],
    "related": []
  }
]
