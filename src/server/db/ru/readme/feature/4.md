# загрузка файлов WIP

## Общее

Несколько компонентов. Провайдер (подход [Compund components](https://habr.com/ru/company/alfa/blog/647013/)), несколько элементов управления (аплоадер файлов, резолвер конфликтов). Тонкости есть с очищением инпута (так как он не позволяет грузить последовательно файлы с одинаковыми именами

Структура компонентов

- file uploader
- file fetcher hook

## File uploader

Что должен уметь

Что должно делать наше решение:

- **Загрузка файлов** (dnd и по кнопке)
- **валидация файлов** (формат/вес/разрешение (ширина Х высота))
- **Разрешение конфликтов** (переименовать новые (загружаемые) или старые (загруженные))

Какими свойствами и возможностями, должно обладать решение

- переиспользуемость
- триггер можно расположить в любом месте приложения (кнопка или dnd область или что угодно)

Набор решений, на которых будет построен компонент

подходы к организации кода

- compound components
- разделение ответственности

фичи реализации:

- валидаторы (fileMaxSize, imageMaxResolution)
- кастомный хук для валидации файлов (useFilesFormField)
- реакт контекст (провайдер + хук)
- dnd

Базовая фича
статья 1 - загрузка валидируемых файлов

- how to upload files react
  статья 2 - прицепляем dnd
  - how to implement dnd in react
    статья 3 - делаем резолвер конфликтов
  - how to make conflict resolver
  - upload scenario

ps:
статья 3 - делаем галерею для отображения загружаемых файлов

- how to make dynamic loading gallery in react

## Как написать загрузчик файлов для react

Зависимости фичи:

1. [валидаторы](https://robzarel.github.io/features/feature/0): [fileMaxSize](https://robzarel.github.io/features/snippet/4) и [imageMaxResolution](https://robzarel.github.io/features/snippet/5)
2. [useFilesFormField](https://robzarel.github.io/features/snippet/14) хук для применения [валидаци к форме](https://robzarel.github.io/features/feature/1) в react

Наша конечная цель это написать **загрузчик файлов**, который обладает следующими свойствами:

- умеет валидировать загружаемые файлы
- умеет отслеживать и передавать "наверх" как общие статусы загрузки, так и статусы каждого конкретного файла
- предоставлять элемент интерфейса для инициации загрузки (кнопку "загрузить")
- загрузчик должен заниматься только загрузкой файлов

### План действий

- Создать контекст и определить его интерфейс
- Задать структуру базовых сущностей загрузчика

### Создаём контекст

Будем использовать react контекст для того, чтобы можно было использовать несколько элементов инициации загрузки (например кнопка и dnd). А так же это даёт возможность расположить элементы управления загрузчиком на любом уровне вложенности компонентов.

```typescript
import type { FilesField } from '../../../utils/form/hooks/types';

const UploaderContext = React.createContext<
  | {
      isUpLoading: boolean;
      selectedFiles: FilesField; // тип FilesField объявлен в хуке 'useFilesFormField'
      handleFilesChange: (event: ChangeEvent<HTMLInputElement>) => void;
      fileInputRef: React.RefObject<HTMLInputElement>;
    }
  | undefined
>(undefined);
```

Затем пишем небольшой кастомный хук, который позволит удобно юзать наш контекст и будет контролировать корректные условия запуска (элемент управления загрузчиком не может быть использован вне контекста загрузчика).

```typescript
const useFilesUploader = () => {
  const context = useContext(UploaderContext);

  if (!context) {
    throw new Error(
      'This component must be used within a <FileUploader> component.'
    );
  }

  return context;
};
```

Для использования контекста загрузчика файлов нам просто нужно будет использовать хук **useFilesUploader**

### Определим сущности, с которыми мы работаем

Поскольку мы грузим набор файлов (их может быть или 2 или 100+), то нам надо отслеживать состояние каждого загружаемого файла (чтобы иметь возможность его отображать).

Для начала опишем статусы (состояния), в которых может находится наш загружаемый файл:

```typescript
const STATUS = {
  initial: 'initial',
  pending: 'pending',
  uploaded: 'uploaded',
  error: 'error',
} as const;
```

Затем определим интерфейсы непосредственно загружаемого файла **UploadEntry** и результат загрузки **UploadResult**

```typescript
type UploadEntry = {
  name: string;
  status: keyof typeof STATUS;
  error: string | null;
  uploaded?: MediaFilesResponse['data'][number];
};

type UploadResult = {
  status: 'fulfilled' | 'rejected';
  value?: {
    status: UploadEntry['status'];
    uploaded?: UploadEntry['uploaded'];
    error?: UploadEntry['error'];
  };
  reason?: any;
};
```

Поля **name**, **status**, **error** в пояснении не нуждаются. А вот в **uploaded** мы будем хранить информацию по нашему успешно загруженному файлу (ответ от нашей ручки api). Часто это может быть полезно, так как в момент добавления файла в хранилище на сервере, ему могут быть даны униальные признаки (идентификаторы), которые возможно будет нужно использовать на клиентской части (например в кейсах, когда потребуется разрешать конфликты дубликатов загружаемых файлов)

**MediaFilesResponse** может быть любым. Этот тип описывает возвращаемое значение от вашего api endpoint. В моём конкретно случае, ответ имеет следующую структуру:

```typescript
type MediaFilesResponse = {
  data: {
    datetimeUpdated: string;
    datetimeUpload: string;
    filename: string;
    files: {
      original: {
        filepath: string;
        height: number;
        width: number;
        mimeType: string;
        resourceType: string;
      };
    };
    metadata: { width: number; height: number };
    id: string;
    namespace: string;
    originalBasename: string;
    originalFilesize: number;
  }[];
  count: number;
};
```

PS:

- директива **as const** используется в typescript для сообщения транспилятору, о том, что ключ данного объекта не будут изменятся. Это даёт возможность нам сделать **union type** по ключам этого объекта с помощью комбинации операторов **keyof typeof**
- структура **UploadResult** по сути описывает результат [Promise.allSettled](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)

### Реализуем компонент

Костяк комопнента достаточно простой.

- Объявляем валидаторы **fileMaxSize** и **imageMaxResolution**
- запускаем хук **useFilesFormField** и получаем объект для хранения и запуска валидации для загружаемых файлов
- реализуем **useEffect**, который будет грузить файлы на сервер
- дополняем компонентом Input для инициации загрузки

```typescript
import React, {
  useState,
  useEffect,
  useCallback,
  useRef,
  useContext,
} from 'react';
import type { ChangeEvent } from 'react';

import { fileMaxSize, imageMaxResolution } from 'some-path/validators';
import type { ValidationResult } from 'some-path/validators';

import { useFilesFormField } from 'some-path/hooks';
import type { FilesField } from 'some-path/hooks/types';

import api from 'some-path/api';
import type { Response as MediaFilesResponse } from 'some-path/api/handlers/media-files/get-media-files';
import type { RequestOptions as MediaFileRequestOptions } from 'some-path/api/handlers/media-files/post-media-files';

const validators = [fileMaxSize(), imageMaxResolution()];

type UploaderProps = {
  onFilesSelected?: () => void;
  onFilesCleared?: () => void;
  onUploadStart?: (uploadEntries: UploadEntry[]) => void;
  onUploadEnd?: (uploadResult: UploadResult[]) => void;
  onFileUploadEnd?: (file: File, obj: Partial<UploadEntry>) => void;
  children?: React.ReactNode;
};

const FilesUploader = (props: UploaderProps) => {
  const {
    onUploadStart,
    onUploadEnd,
    onFileUploadEnd,
    onFilesSelected,
    onFilesCleared,
    children,
  } = props;

  const [isUpLoading, setUpLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const selectedFiles = useFilesFormField('files', validators);

  const resetUploader = useCallback(() => {
    setUpLoading(false);
    clearSelectedFiles();

    onFilesCleared?.();
  }, [clearSelectedFiles, onFilesCleared]);

  useEffect(() => {
    const uploadMediaFiles = async () => {
      if (selectedFiles.value.length === 0) {
        return;
      }

      setUpLoading(true);

      onUploadStart?.(
        formatToUploadEntries(selectedFiles.value, selectedFiles.error)
      );

      const allPromises = selectedFiles.value
        .filter((item, index) => !selectedFiles.error[index])
        .map(async (file) => {
          const options: MediaFileRequestOptions = { source: file };

          const uploadPromise = api.post.mediaFile(options);
          let uploadResult: Partial<UploadEntry> = {};

          try {
            const uploaded = await uploadPromise;
            uploadResult = {
              status: STATUS.uploaded,
              uploaded,
            };
          } catch (err) {
            const msg =
              err instanceof Error
                ? err.message
                : 'Unknown Error: api.post.mediaFiles';
            uploadResult = {
              status: STATUS.error,
              error: msg,
            };
          } finally {
            onFileUploadEnd?.(file, uploadResult);
          }

          return uploadPromise;
        });

      const uploadingResult = await Promise.allSettled(allPromises);
      onUploadEnd?.(uploadingResult);

      resetUploader();
    };

    uploadMediaFiles();
  }, [
    selectedFiles.value,
    selectedFiles.error,
    clearSelectedFiles,
    resetUploader,
    onFileUploadEnd,
    onUploadStart,
    onUploadEnd,
  ]);

  const handleFilesChange = (event: ChangeEvent<HTMLInputElement>) => {
    const files: File[] = event.target.files
      ? Array.from(event.target.files)
      : [];
    selectedFiles.handleChange(files);
    onFilesSelected?.();

    fileInputRef.current && (fileInputRef.current.value = '');
  };

  return (
    <UploaderContext.Provider
      value={{
        isUpLoading,
        selectedFiles,
        handleFilesChange,
      }}
    >
      <div className={Styles.uploaderChildrens}>{children}</div>
    </UploaderContext.Provider>
  );
};
```

Стоит обратить внимание на строчку

```typescript
fileInputRef.current && (fileInputRef.current.value = '');
```

Таким оборазом мы сбрасываем input value, для того, чтобы не блокировать повторный выбор (и загрузку) файлов с одинаковыми именами.

## Кнопка загрузки файлов

Инпут для загрузки файлов

```typescript
FilesUploader.Input = function Input({ label = '+ Загрузить' }) {
  const { fileInputRef, handleFilesChange } = useFilesUploader();

  return (
    <div className={Styles.download} id={CONTROL_ID.INPUT}>
      <input
        ref={fileInputRef}
        className={Styles.downloadInput}
        type='file'
        multiple
        onChange={handleFilesChange}
        id='file-uploader-input-button'
      />
      <label
        className={Styles.downloadLabel}
        htmlFor='file-uploader-input-button'
      >
        {label}
      </label>
    </div>
  );
};
```

## Применение

Теперь мы можем просто обернуть приложение в контекст **FilesUploader** и использовать **FilesUploader.Input** и **FilesUploader.DnD** на любом уровне вложенности. Например:

```typescript
import FilesUploader from './files-uploader';
import type { UploadEntry, UploadResult } from './files-uploader';
import Header from './header';

const Page = () => {
  const handleFilesSelecting = () => {
    /* files selecting processing */
  };
  const handleUploadingStart = (uploadEntries: UploadEntry[]) => {
    /* uploading start processing */
  };
  const handleUploadingEnd = (uploadResult: UploadResult[]) => {
    /* uploading end processing */
  };
  const handleFilesClearing = () => {
    /* uploader clearing processing */
  };
  const handleFileUploadingEnd = (file: File, obj: Partial<UploadEntry>) => {
    /* single file uploading processing */
  };

  return (
    <div>
      <FilesUploader
        onFilesSelected={handleFilesSelecting}
        onUploadStart={handleUploadingStart}
        onUploadEnd={handleUploadingEnd}
        onFilesCleared={handleFilesClearing}
        onFileUploadEnd={handleFileUploadingEnd}
      >
        <Header />
        {/* render some uploading view */}
      </FilesUploader>
    </div>
  );
};
```

```typescript
import FilesUploader from './files-uploader';

const Header = () => {
  return (
    <div>
      <h1>Header</h1>
      <FilesUploader.Input />
    </div>
  );
};
```

Пропсы **onFilesSelected**, **onFilesCleared**, **onUploadStart**, **onFileUploadEnd** дают возможность в рутовом компоненте получать актуальную информацию о статусе/прогрессе как всего процесса загрузки, так и конкретного элемента.

## DND

Непосредственная реализация DND описна в [отдельной фиче](https://robzarel.github.io/features/feature/13)
Здесь мы просто соединяем нашу DND фичу с загрузчиком файлов

```typescript
import DndContainer from '../dnd-container';

FilesUploader.DnD = function DnD({ title = 'Перетащите сюда медиафайлы' }) {
  const { isUpLoading, selectedFiles, handleFilesDrop } = useFilesUploader();
  const isScenarioActive = isUpLoading || selectedFiles.value.length > 0;

  return (
    <div className={Styles.dnd}>
      <DndContainer
        title={title}
        onDrop={handleFilesDrop}
        disabled={isScenarioActive}
      />
    </div>
  );
};
```

Таким образом вместе с загрузчиком, мы поставляем 2 элемента управления: **FilesUploader.Input** и **FilesUploader.DnD**.
Они могут быть расположены где угодно в рамках нашего контекста **FilesUploader**
