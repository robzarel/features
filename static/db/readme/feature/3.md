# Переключение цветовых тем в приложении

## Что хотим получить
Предет тем, как приступим к решение задачи темизации нашего react приложения сформулируем возможности, которые должна обладать наша будущая система:

### Возможность изменить стилизацию приложения (css и js).
Это в общем то звучит как основная цель))

Часть наших элементов интерфейсов, могут менять своё отображение только на основе свойст, которые мы пробрасываем внуть компонентов. Например так работают большинство библиотек элементов (закрыты к изменению, но имеют апи для управления). Следовательно где-то в коде уже наших компонентов мы должны иметь возможность получить значение текущей темы

### Возможность из любого места приложения инициировать изменение темы
Внутри наших компонентов, должен быть доступен метод для смены темы.
При этом мы заранее не можем знать, на какой "глубине/уровне вложенности" этот элемент управления темой может появится. Надо предусмотреть все возможности

### Возможность расширения
Мы не должны быть ограничены только одной цветовой темой. И нам не должно быть мучительно больно, если наши старшие братья по интерфейсам дизайнеры вдруг запилят к стандартным "светлой" и "тёмной" темам ещё и "малиновую, по случаю дня рождения компании"

Кажется теперь, когда мы понимаем все требования к нашей системе, можно переходить к проектированию решения.

PS:
В рамках нашего скоупа обсуждения, мы не будем затрагивать вопросы всей дизайн системы, а сосредоточимся только на цветовых схемах. 
Тема дизайн систем очень объёмная и есть множество достойных источников на эту тему. 

## Вопросы перед началом
Итак, на какие вопросы нам нужно ответить перед тем, как нырнуть в решение задачи:
1) как мы будем `переключать` цветовую тему
2) где и как будем описывать связки цветов
3) как мы будем применять тему внутри наших `css` файлов и `react` компонентов
4) как мы дадим нашим компонентам возможность триггерить смену цветовой темы


## Решения

### Переключение темы
Переключать тему мы будем очень просто - изменяя содержимое data-theme аттрибута на html элементе.

WIPWIPWIPWIPWIP
---
---------
---
---------


## Общее

идея простая - создаём контекст, отдаём его вниз. Так же создаём компоненты управления через подход [Compund components](https://habr.com/ru/company/alfa/blog/647013/)

### Создание:

css

- создаём набор токенов
- собираем из них темы
- подключаем темы в рутовый компонет

См подробности в сниппете [css tokens](https://robzarel.github.io/features/snippet/18)

react

- создаём провайдер темы (ThemeProvider)
  -- объявляем внутр состояние темы и меняем его через торчащую наружу функцию
  -- сохраняем в сторадже и не забываем проставлять на html
  -- так же создаём useTheme хук и торчим его наружу для использования в приложении
- оборачиваем приложение в провайдер

См подробности в сниппете [ThemeProvider](https://robzarel.github.io/features/snippet/19)

### "Включение" темы

- переключатель: просто юзаем useTheme и хендлим контролы
- css: используем переменные из обьявленных тем

### Прокидываем контекст вниз

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';

import ThemeProvider from './components/theme-provider';
import App from './pages'; // рутовый компонент

import './index.css'; // базовые стили нашего приложения
import './components/theme-provider/themes.css'; // подключаем глобальные переменные для переключения тем

const root = document.getElementById('root') as HTMLElement;

ReactDOM.createRoot(root).render(
  <ThemeProvider>
    <App />
  </ThemeProvider>
);
```

### Ловим контекст и проставляем тему

#### CSS

```css
  .class {
    color: rgba(var(--accent), .75);
  }

  ...
```

#### Typescript

```typescript
  import { useTheme } from '../../components/theme-provider';
  import Styles from './index.module.css';
  ...

  const component = () => {

    const { theme } = useTheme();
    const value = theme === 'dark' ? option_1 : option_2;

    return (
      <div className={Styles.class}>{/* some markup that use selected theme value */}</div>
    );
  }

```
